/**
 * @Section Nuclear attraction integrals between different Shell-types (e.g. s, p, d, f)
 * ------------------------------------------------------------------------------------
 * The benefits of this is due to loop unrolling and compiler optimization.
 * The disadvantages is the increase in probability of error and code bloating.
 *
 * @notes Generated by "generate_integrals.py" file. With a bit of copy-pasting.
 */
#include "../include/integral_coeffs.cuh"
#include "../include/cuda_utils.cuh"

#include <stdio.h>


__device__ double gbasis::compute_s_s_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_s_px_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_s_py_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_s_pz_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_s_dxx_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 2>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 2>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<2, 0, 2>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 0, 0>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_s_dyy_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 0, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 2, 0>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_s_dzz_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 2>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_s_dxy_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 1, 0>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_s_dxz_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 1>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_s_dyz_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 1>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_px_px_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<2, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 0, 0>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_px_py_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 1, 0>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_px_pz_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 1>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_px_dxx_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 1, 2>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 2>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<2, 1, 2>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<3, 1, 2>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 3, 0, 0>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_px_dyy_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 0, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 2, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 0, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 2, 0>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_px_dzz_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 2>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 2>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_px_dxy_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<2, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<2, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 1, 0>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_px_dxz_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<2, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<2, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 0, 1>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_px_dyz_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 1>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 1, 1>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_py_py_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 2, 0>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_py_pz_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 1>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_py_dxx_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 2>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 2>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 2>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 2>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<2, 0, 2>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<2, 0, 2>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 1, 0>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_py_dyy_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 1, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 2, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<3, 1, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 3, 0>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_py_dzz_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 2>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 2>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_py_dxy_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 2, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 2, 0>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_py_dxz_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 1>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 1, 1>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_py_dyz_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 2, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 2, 1>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_pz_pz_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 2>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_pz_dxx_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 2>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 1, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 2>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 1, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 2>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 1, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 2>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 1, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<2, 0, 2>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 1, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<2, 0, 2>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 1, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 0, 1>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_pz_dyy_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 1, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 1, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 1, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 1, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 0, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 1, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 2, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 0, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 1, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 2, 1>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_pz_dzz_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 1, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 1, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 1, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 2>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<3, 1, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 3>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_pz_dxy_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 1, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 1, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 1, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 1, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 1>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 1, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 1, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 1, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 1, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 1, 1>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_pz_dxz_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 2>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 2>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_pz_dyz_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 2>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 2>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_dxx_dxx_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 2, 2>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 2, 2>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<2, 2, 2>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<3, 2, 2>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 3, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<4, 2, 2>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 4, 0, 0>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_dxx_dyy_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 2, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 2, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 2, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 0, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 2, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 2, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 2, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 2, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 0, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 2, 0>(alpha, P, beta, pt);
    output += gbasis::E<2, 2, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<2, 2, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<2, 2, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 0, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 2, 0>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_dxx_dzz_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 2, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 2, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 2, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 2>(alpha, P, beta, pt);
    output += gbasis::E<1, 2, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 2, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<1, 2, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 2>(alpha, P, beta, pt);
    output += gbasis::E<2, 2, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<2, 2, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<2, 2, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 0, 2>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_dxx_dxy_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 2, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 2, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 2, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 2, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<2, 2, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<2, 2, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<3, 2, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 3, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<3, 2, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 3, 1, 0>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_dxx_dxz_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 2, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 2, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<1, 2, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 2, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<2, 2, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<2, 2, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<3, 2, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 3, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<3, 2, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 3, 0, 1>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_dxx_dyz_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 2, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 2, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 2, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 2, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 1>(alpha, P, beta, pt);
    output += gbasis::E<1, 2, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 2, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<1, 2, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 2, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 1, 1>(alpha, P, beta, pt);
    output += gbasis::E<2, 2, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<2, 2, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<2, 2, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<2, 2, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 1, 1>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_dyy_dyy_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 2, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 2, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 2, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 2, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<3, 2, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 3, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<4, 2, 2>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 4, 0>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_dyy_dzz_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 2, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 2, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 2, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 2>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 2, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 2, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 2, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 2>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 2, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 2, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 2, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 2, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 2, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 0, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 2, 2>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_dyy_dxy_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 2, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 2, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 2, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 2, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<3, 2, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 3, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 2, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 2, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 2, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 2, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<3, 2, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 3, 0>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_dyy_dxz_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 2, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 2, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 2, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 2, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 2, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 2, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 2, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 2, 1>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 2, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 2, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 2, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 2, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 1, 1>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 2, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 2, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 2, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 2, 1>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_dyy_dyz_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 2, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 2, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 2, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 2, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 2, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 2, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 2, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 2, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<3, 2, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 3, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<3, 2, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 3, 1>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_dzz_dzz_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 2, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 2, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 2, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 2>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<3, 2, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 3>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<4, 2, 2>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 4>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_dzz_dxy_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 2, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 2, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 2, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 2>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 2, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 2, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 2, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 2>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 2, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 2, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 2, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 2>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 2, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 2, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 1, 1>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 2, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 1, 2>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_dzz_dxz_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 2, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 2, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 2, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 2>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<3, 2, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 3>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 2, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 2, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 2, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 2>(alpha, P, beta, pt);
    output += gbasis::E<1, 0, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<3, 2, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 3>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_dzz_dyz_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 2, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 2, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 2, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 2>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<3, 2, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 3>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 2, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 2, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 2, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 2>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<3, 2, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 3>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_dxy_dxy_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 2, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 2, 0>(alpha, P, beta, pt);
    output += gbasis::E<2, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<2, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<2, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 0>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 2, 0>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_dxy_dxz_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 1>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 1, 1>(alpha, P, beta, pt);
    output += gbasis::E<2, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<2, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<2, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<2, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 1, 1>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_dxy_dyz_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 2, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 2, 1>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 1, 1>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 2, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 0, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 2, 1>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_dxz_dxz_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 2>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 2>(alpha, P, beta, pt);
    output += gbasis::E<2, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<2, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<2, 1, 1>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 0>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 2, 0, 2>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_dxz_dyz_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 2>(alpha, P, beta, pt);
    output += gbasis::E<0, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 2>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 0, 2>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 1, 1>(alpha, P, beta, pt);
    output += gbasis::E<1, 1, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 0, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 1, 1, 2>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
__device__ double gbasis::compute_dyz_dyz_nuclear_attraction_integral(const double& alpha, const double3& A_coord, const double& beta, const double3& B_coord, const double3& pt, const double3& P)
{
    double output = gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<0, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 0, 2>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<1, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 1, 2>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<0, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 2, 0>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<1, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 2, 1>(alpha, P, beta, pt);
    output += gbasis::E<0, 0, 0>(alpha, A_coord.x, beta, B_coord.x) *  gbasis::E<2, 1, 1>(alpha, A_coord.y, beta, B_coord.y) *  gbasis::E<2, 1, 1>(alpha, A_coord.z, beta, B_coord.z) *  gbasis::R<0, 0, 2, 2>(alpha, P, beta, pt);
    return output * (2.0 * CUDART_PI_D) / (alpha + beta);
}
